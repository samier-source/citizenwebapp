// script.js
// Leaflet map + Firebase (optional) + localStorage fallback.
// Edit FIREBASE_CONFIG below to enable Firestore sync across devices.
// If FIREBASE_CONFIG is null/empty, localStorage is used automatically.

/////////////////////// CONFIG ///////////////////////

// If you want to use Firebase (shared reports), paste your Firebase Web SDK config here.
// Example:
// const FIREBASE_CONFIG = {
//   apiKey: "...",
//   authDomain: "...",
//   projectId: "...",
//   storageBucket: "...",
//   messagingSenderId: "...",
//   appId: "..."
// };
const FIREBASE_CONFIG = null; // <--- put your firebase config object here, or leave null to use localStorage

// Firestore collection name (if using Firebase)
const FIRESTORE_COLLECTION = 'road-issues';

// Local storage key (fallback)
const LOCAL_KEY = 'citizen_reports_v1';

//////////////////////////////////////////////////////

// runtime state
let map, isAuthority = false, tmpPickHandler = null;
let markers = {}; // id -> leaflet layer
let newReportLatLng = null;
let activeIssueId = null;

// Helpers
function uid(){ return 'r_' + Date.now() + '_' + Math.random().toString(36).slice(2,8); }
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

//////////////////// Storage layer (abstract) ////////////////////

let storageImpl = null; // will be { init(), add(issue), onChange(cb), update(id, patch) }

async function initLocalStorage() {
  function loadAll(){
    const raw = localStorage.getItem(LOCAL_KEY);
    return raw ? JSON.parse(raw) : [];
  }
  function saveAll(arr){ localStorage.setItem(LOCAL_KEY, JSON.stringify(arr)); }
  return {
    async init(){ /* nothing */ },
    async add(issue){
      const arr = loadAll();
      arr.push(issue);
      saveAll(arr);
      // notify
      if(storageImpl._cb) storageImpl._cb('added', issue);
    },
    async onChange(cb){
      storageImpl._cb = cb;
      // initial push existing
      const all = loadAll();
      all.forEach(i => cb('added', i));
    },
    async update(id, patch){
      const arr = loadAll();
      const idx = arr.findIndex(x => x.id === id);
      if(idx === -1) return;
      arr[idx] = {...arr[idx], ...patch};
      saveAll(arr);
      if(storageImpl._cb) storageImpl._cb('modified', arr[idx]);
    }
  };
}

//////////////////// Firebase layer (optional) ////////////////////

async function initFirebaseLayer(config){
  // lazy import SDKs only if needed
  const { initializeApp } = await import('https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js');
  const { getAuth, signInAnonymously, onAuthStateChanged } = await import('https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js');
  const { getFirestore, collection, addDoc, onSnapshot, query, updateDoc, doc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js');

  const app = initializeApp(config);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Ensure anonymous sign-in
  signInAnonymously(auth).catch(e => console.warn('FB auth:', e));
  // simple wrapper
  return {
    async init(){ /* nothing */ },
    async add(issue){
      // add createdAt server timestamp
      const toSave = {...issue};
      toSave.createdAt = serverTimestamp();
      const colRef = collection(db, FIRESTORE_COLLECTION);
      await addDoc(colRef, toSave);
    },
    async onChange(cb){
      const q = query(collection(db, FIRESTORE_COLLECTION));
      onSnapshot(q, (snap) => {
        snap.docChanges().forEach(change => {
          const data = change.doc.data();
          const id = change.doc.id;
          const item = { id, ...data };
          if(change.type === 'added') cb('added', item);
          if(change.type === 'modified') cb('modified', item);
          if(change.type === 'removed') cb('removed', item);
        });
      }, err => {
        console.error('Firestore onSnapshot error', err);
      });
    },
    async update(id, patch){
      const docRef = doc(db, FIRESTORE_COLLECTION, id);
      await updateDoc(docRef, patch);
    }
  };
}

//////////////////// App UI & Map ////////////////////

function buildPopupHtml(issue){
  const imgHtml = issue.photo ? `<img class="issue-photo" src="${escapeHtml(issue.photo)}">` : '';
  const authControls = isAuthority ? `
    <div style="margin-top:8px">
      <label style="font-weight:600">Update Status</label>
      <select id="status-select-${issue.id}" style="width:100%;padding:6px;border-radius:6px;border:1px solid #ddd">
        <option ${issue.status==='Received'?'selected':''}>Received</option>
        <option ${issue.status==='In Progress'?'selected':''}>In Progress</option>
        <option ${issue.status==='Resolved'?'selected':''}>Resolved</option>
      </select>
      <button id="update-btn-${issue.id}" style="margin-top:8px;padding:8px 10px;background:#16a34a;color:white;border:0;border-radius:6px;cursor:pointer">Update</button>
    </div>` : '';

  return `
    <div style="min-width:220px">
      <div style="font-weight:700;margin-bottom:6px">${escapeHtml(issue.type)}</div>
      <div style="font-size:13px;color:#333">${escapeHtml(issue.desc||'')}</div>
      <div style="font-size:12px;color:#666;margin-top:8px">By: ${escapeHtml(issue.reportedBy||'Anonymous')}</div>
      <div style="font-size:12px;color:#666">Status: <strong>${escapeHtml(issue.status)}</strong></div>
      ${imgHtml}
      ${authControls}
    </div>`;
}

function addMarker(issue){
  if(!issue.lat || !issue.lng) return;
  const col = issue.status === 'Resolved' ? '#10b981' : (issue.status === 'In Progress' ? '#f59e0b' : '#c30000');
  const layer = L.circleMarker([issue.lat, issue.lng], { radius:8, fillColor: col, color:'#fff', weight:1, fillOpacity:0.95 }).addTo(map);
  layer.bindPopup(buildPopupHtml(issue), { maxWidth:320 });
  layer.on('popupopen', () => {
    // wire update button if authority
    if(isAuthority){
      const sel = document.getElementById(`status-select-${issue.id}`);
      const btn = document.getElementById(`update-btn-${issue.id}`);
      if(btn && sel){
        btn.onclick = async () => {
          const newStatus = sel.value;
          await storageImpl.update(issue.id, { status: newStatus });
        };
      }
    }
  });
  markers[issue.id] = layer;
}

function removeMarker(id){
  if(markers[id]) { try{ map.removeLayer(markers[id]); }catch(e){} delete markers[id]; }
}

function redrawAll(items){
  // remove old
  Object.keys(markers).forEach(k => removeMarker(k));
  // add in order
  items.forEach(i => addMarker(i));
}

async function startupStorage(){
  if(FIREBASE_CONFIG){
    try{
      storageImpl = await initFirebaseLayer(FIREBASE_CONFIG);
      console.log('Using Firebase storage');
    } catch(e){
      console.warn('Firebase init failed, falling back to localStorage', e);
      storageImpl = await initLocalStorage();
    }
  } else {
    storageImpl = await initLocalStorage();
    console.log('Using localStorage');
  }
  await storageImpl.init();
}

async function initApp(){
  // map init
  map = L.map('map').setView([19.0896, 72.8656], 11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors', maxZoom:19 }).addTo(map);

  // UI elements
  const authBtn = document.getElementById('toggleAuthorityBtn');
  const raiseBtn = document.getElementById('raiseIssueBtn');
  const reportModal = document.getElementById('reportModal');
  const closeReport = document.getElementById('closeReportModal');
  const cancelReport = document.getElementById('cancelReport');
  const pickLocBtn = document.getElementById('pickLocBtn');
  const latlngInput = document.getElementById('issueLatLng');
  const photoInput = document.getElementById('issuePhoto');
  const reportForm = document.getElementById('reportForm');
  const viewModal = document.getElementById('viewModal');
  const viewBody = document.getElementById('viewBody');

  // start storage
  await startupStorage();

  // wire storage changes -> redraw
  await storageImpl.onChange(async (type, item) => {
    // gather all items (for local impl we re-run loader)
    if(storageImpl === null) return;
    // For local impl, it calls cb per item; easiest is to rebuild full list:
    if(FIREBASE_CONFIG){
      // firebase implementation sends added/modified with full item; maintain markers incremental
      if(type === 'added') addMarker(item);
      if(type === 'modified'){ removeMarker(item.id); addMarker(item); }
      if(type === 'removed'){ removeMarker(item.id); }
    } else {
      // local impl: rebuild from localStorage
      const raw = localStorage.getItem(LOCAL_KEY) || '[]';
      const arr = JSON.parse(raw);
      redrawAll(arr);
    }
  });

  // initial load for firebase: firebase.onChange will call added callbacks.
  if(!FIREBASE_CONFIG){
    const raw = localStorage.getItem(LOCAL_KEY) || '[]';
    const arr = JSON.parse(raw);
    redrawAll(arr);
  }

  // toggle authority
  authBtn.addEventListener('click', () => {
    isAuthority = !isAuthority;
    authBtn.textContent = isAuthority ? 'Switch to Citizen View' : 'Switch to Authority View';
    // refresh popups to show/hide controls
    if(FIREBASE_CONFIG){
      // easiest: force full redraw by removing and re-adding via requesting all current docs
      // but we rely on onChange events; simple approach: reload page state from storage
      // For local we call redrawAll; for firebase user will see controls in subsequent popupopen because addMarker uses isAuthority state
    } else {
      const raw2 = localStorage.getItem(LOCAL_KEY) || '[]';
      const arr2 = JSON.parse(raw2);
      redrawAll(arr2);
    }
  });

  // open report modal: prefill center coords
  raiseBtn.addEventListener('click', () => {
    const c = map.getCenter();
    latlngInput.value = `${c.lat.toFixed(6)}, ${c.lng.toFixed(6)}`;
    document.getElementById('issueType').value = 'Accident';
    document.getElementById('issueDesc').value = '';
    photoInput.value = '';
    reportModal.classList.remove('hidden');
  });

  // close modal
  closeReport.addEventListener('click', () => {
    reportModal.classList.add('hidden');
    if(tmpPickHandler){ map.off('click', tmpPickHandler); tmpPickHandler = null; document.getElementById('pickLocBtn').textContent = 'Pick on map'; }
  });
  cancelReport.addEventListener('click', () => {
    reportModal.classList.add('hidden');
    if(tmpPickHandler){ map.off('click', tmpPickHandler); tmpPickHandler = null; document.getElementById('pickLocBtn').textContent = 'Pick on map'; }
  });

  // pick on map
  pickLocBtn.addEventListener('click', () => {
    pickLocBtn.textContent = 'Click on map...';
    if(tmpPickHandler){ map.off('click', tmpPickHandler); tmpPickHandler = null; }
    tmpPickHandler = function(e){
      latlngInput.value = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
      pickLocBtn.textContent = 'Pick on map';
      map.off('click', tmpPickHandler);
      tmpPickHandler = null;
    };
    map.on('click', tmpPickHandler);
  });

  // submit report
  reportForm.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    const type = document.getElementById('issueType').value;
    const desc = document.getElementById('issueDesc').value.trim();
    const latlng = latlngInput.value.trim();
    if(!latlng){ alert('Pick a location'); return; }
    const [latS, lngS] = latlng.split(',').map(s => s.trim());
    const lat = parseFloat(latS), lng = parseFloat(lngS);
    if(Number.isNaN(lat)||Number.isNaN(lng)){ alert('Invalid coordinates'); return; }

    let photoData = null;
    const f = photoInput.files[0];
    if(f){
      photoData = await new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.onerror = rej;
        r.readAsDataURL(f);
      });
    }

    const item = {
      id: uid(),
      type, desc,
      lat, lng,
      photo: photoData,
      status: 'Received',
      reportedBy: 'Anonymous',
      createdAt: Date.now()
    };

    await storageImpl.add(item);
    reportModal.classList.add('hidden');
    if(!FIREBASE_CONFIG){
      // local: redraw will be triggered via onChange callback; ensure immediate add
      const raw = localStorage.getItem(LOCAL_KEY) || '[]';
      const arr = JSON.parse(raw);
      arr.push(item);
      localStorage.setItem(LOCAL_KEY, JSON.stringify(arr));
      redrawAll(arr);
    }
  });

  // view modal close
  document.getElementById('closeViewModal').addEventListener('click', () => document.getElementById('viewModal').classList.add('hidden'));
  document.getElementById('closeViewBtn').addEventListener('click', () => document.getElementById('viewModal').classList.add('hidden'));

  // map click in citizen mode opens report modal and sets latlng
  map.on('click', (e) => {
    if(isAuthority) return;
    // open report modal with clicked coords
    document.getElementById('issueLatLng').value = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
    document.getElementById('issueType').value = 'Accident';
    document.getElementById('issueDesc').value = '';
    document.getElementById('issuePhoto').value = '';
    document.getElementById('reportModal').classList.remove('hidden');
  });
}

// start app
window.addEventListener('DOMContentLoaded', () => {
  initApp().catch(e => {
    console.error('App init error', e);
    alert('App failed to start. Check console for details.');
  });
});
